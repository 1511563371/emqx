emqx_conf_schema {

    cluster_name {
                   desc {
                         en: """Human-friendly name of the EMQX cluster."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_discovery_strategy {
                   desc {
                         en: """Service discovery method for the cluster nodes."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_autoclean {
                   desc {
                         en: """Remove disconnected nodes from the cluster after this interval."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_autoheal {
                   desc {
                         en: """If <code>true</code>, the node will try to heal network partitions
 automatically."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_proto_dist {
                   desc {
                         en: """The Erlang distribution protocol for the cluster."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_static_seeds {
                   desc {
                         en: """List EMQX node names in the static cluster. See <code>node.name</code>."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_mcast_addr {
                   desc {
                         en: """Multicast IPv4 address."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_mcast_ports {
                   desc {
                         en: """List of UDP ports used for service discovery.<br/>
Note: probe messages are broadcast to all the specified ports."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_mcast_iface {
                   desc {
                         en: """Local IP address the node discovery service needs to bind to."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_mcast_ttl {
                   desc {
                         en: """Time-to-live (TTL) for the outgoing UDP datagrams."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_mcast_loop {
                   desc {
                         en: """If <code>true</code>, loop UDP datagrams back to the local socket."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_mcast_sndbuf {
                   desc {
                         en: """Size of the kernel-level buffer for outgoing datagrams."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_mcast_recbuf {
                   desc {
                         en: """Size of the kernel-level buffer for incoming datagrams."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_mcast_buffer {
                   desc {
                         en: """Size of the user-level buffer."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_dns_name {
                   desc {
                         en: """The domain name of the EMQX cluster."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_dns_app {
                   desc {
                         en: """The symbolic name of the EMQX service."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_etcd_server {
                   desc {
                         en: """List of endpoint URLs of the etcd cluster"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_etcd_prefix {
                   desc {
                         en: """Key prefix used for EMQX service discovery."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_etcd_node_ttl {
                   desc {
                         en: """Expiration time of the etcd key associated with the node.
It is refreshed automatically, as long as the node is alive."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_etcd_ssl {
                   desc {
                         en: """Options for the TLS connection to the etcd cluster."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_k8s_apiserver {
                   desc {
                         en: """Kubernetes API endpoint URL."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_k8s_service_name {
                   desc {
                         en: """EMQX broker service name."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_k8s_address_type {
                   desc {
                         en: """Address type used for connecting to the discovered nodes."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_k8s_app_name {
                   desc {
                         en: """This parameter should be set to the part of the <code>node.name</code>
before the '@'.<br/>
For example, if the <code>node.name</code> is <code>emqx@127.0.0.1</code>, then this parameter
should be set to <code>emqx</code>."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_k8s_namespace {
                   desc {
                         en: """Kubernetes namespace."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_k8s_suffix {
                   desc {
                         en: """Node name suffix.<br/>
Note: this parameter is only relevant when <code>address_type</code> is <code>dns</code>
or <code>hostname</code>."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_name {
                   desc {
                         en: """Unique name of the EMQX node. It must follow <code>%name%@FQDN</code> or
 <code>%name%@IPv4</code> format."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_cookie {
                   desc {
                         en: """Secret cookie is a random string that should be the same on all nodes in
 the given EMQX cluster, but unique per EMQX cluster. It is used to prevent EMQX nodes that
 belong to different clusters from accidentally connecting to each other."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_data_dir {
                   desc {
                         en: """
Path to the persistent data directory.
Possible auto-created subdirectories are:
  - `mnesia/<node_name>`: EMQX's built-in database directory.
    For example, `mnesia/emqx@127.0.0.1`.
    There should be only one such subdirectory.
    Meaning, in case the node is to be renamed (to e.g. `emqx@10.0.1.1`),
    the old dir should be deleted first.
  - `configs`: Generated configs at boot time, and cluster/local override configs.
  - `patches`: Hot-patch beam files are to be placed here.
  - `trace`: Trace log files.

**NOTE**: One data dir cannot be shared by two or more EMQX nodes.
"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_config_files {
                   desc {
                         en: """List of configuration files that are read during startup. The order is
 significant: later configuration files override the previous ones."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_global_gc_interval {
                   desc {
                         en: """Periodic garbage collection interval."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_crash_dump_file {
                   desc {
                         en: """Location of the crash dump file"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_crash_dump_seconds {
                   desc {
                         en: """The number of seconds that the broker is allowed to spend writing
a crash dump"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_crash_dump_bytes {
                   desc {
                         en: """The maximum size of a crash dump file in bytes."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_dist_net_ticktime {
                   desc {
                         en: """This is the approximate time an EMQX node may be unresponsive until it is considered down and thereby disconnected."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_backtrace_depth {
                   desc {
                         en: """Maximum depth of the call stack printed in error messages and
 <code>process_info</code>."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_applications {
                   desc {
                         en: """List of Erlang applications that shall be rebooted when the EMQX broker joins
 the cluster."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    node_etc_dir {
                   desc {
                         en: """<code>etc</code> dir for the node"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    db_backend {
                   desc {
                         en: """
Select the backend for the embedded database.<br/>
<code>rlog</code> is the default backend,
that is suitable for very large clusters.<br/>
<code>mnesia</code> is a backend that offers decent performance in small clusters.
"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    db_role {
                   desc {
                         en: """
Select a node role.<br/>
<code>core</code> nodes provide durability of the data, and take care of writes.
It is recommended to place core nodes in different racks or different availability zones.<br/>
<code>replicant</code> nodes are ephemeral worker nodes. Removing them from the cluster
doesn't affect database redundancy<br/>
It is recommended to have more replicant nodes than core nodes.<br/>
Note: this parameter only takes effect when the <code>backend</code> is set
to <code>rlog</code>.
"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    db_core_nodes {
                   desc {
                         en: """
List of core nodes that the replicant will connect to.<br/>
Note: this parameter only takes effect when the <code>backend</code> is set
to <code>rlog</code> and the <code>role</code> is set to <code>replicant</code>.<br/>
This value needs to be defined for manual or static cluster discovery mechanisms.<br/>
If an automatic cluster discovery mechanism is being used (such as <code>etcd</code>),
there is no need to set this value.
"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    db_rpc_module {
                   desc {
                         en: """
Protocol used for pushing transaction logs to the replicant nodes.
"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    db_tlog_push_mode {
                   desc {
                         en: """
In sync mode the core node waits for an ack from the replicant nodes before sending the next
transaction log entry.
"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    db_default_shard_transport {
                   desc {
                         en: """Defines the default transport for pushing transaction logs.<br/>This may be overridden on a per-shard basis in <code>db.shard_transports</code>.<code>gen_rpc</code> uses the <code>gen_rpc</code> library, <code>distr</code> uses the Erlang distribution.<br/>"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    db_shard_transports {
                   desc {
                         en: """Allows to tune the transport method used for transaction log replication, on a per-shard basis.<br/><code>gen_rpc</code> uses the <code>gen_rpc</code> library, <code>distr</code> uses the Erlang distribution.<br/>If not specified, the default is to use the value set in <code>db.default_shard_transport</code>."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_call_retry_interval {
                   desc {
                         en: """Time interval to retry after a failed call."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_call_max_history {
                   desc {
                         en: """Retain the maximum number of completed transactions (for queries)."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    cluster_call_cleanup_interval {
                   desc {
                         en: """Time interval to clear completed but stale transactions.
Ensure that the number of completed transactions is less than the <code>max_history</code>."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_mode {
                   desc {
                         en: """In <code>sync</code> mode the sending side waits for the ack from the receiving side."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_driver {
                   desc {
                         en: """Transport protocol used for inter-broker communication"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_async_batch_size {
                   desc {
                         en: """The maximum number of batch messages sent in asynchronous mode. Note that this configuration does not work in synchronous mode."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_port_discovery {
                   desc {
                         en: """<code>manual</code>: discover ports by <code>tcp_server_port</code>.<br/><code>stateless</code>: discover ports in a stateless manner, using the following algorithm. If node name is <code>emqxN@127.0.0.1</code>, where the N is an integer, then the listening port will be 5370 + N."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_tcp_server_port {
                   desc {
                         en: """Listening port used by RPC local service.<br/> Note that this config only takes effect when rpc.port_discovery is set to manual."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_ssl_server_port {
                   desc {
                         en: """Listening port used by RPC local service.<br/> Note that this config only takes effect when rpc.port_discovery is set to manual and <code>driver</code> is set to <code>ssl</code>."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_tcp_client_num {
                   desc {
                         en: """Set the maximum number of RPC communication channels initiated by this node to each remote node."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_connect_timeout {
                   desc {
                         en: """Timeout for establishing an RPC connection."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_certfile {
                   desc {
                         en: """Path to TLS certificate file used to validate identity of the cluster nodes. Note that this config only takes effect when <code>rpc.driver</code> is set to <code>ssl</code>."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_keyfile {
                   desc {
                         en: """Path to the private key file for the <code>rpc.certfile</code>.<br/>Note: contents of this file are secret, so it's necessary to set permissions to 600."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_cacertfile {
                   desc {
                         en: """Path to certification authority TLS certificate file used to validate <code>rpc.certfile</code>.<br/>Note: certificates of all nodes in the cluster must be signed by the same CA."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_send_timeout {
                   desc {
                         en: """Timeout for sending the RPC request."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_authentication_timeout {
                   desc {
                         en: """Timeout for the remote node authentication."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_call_receive_timeout {
                   desc {
                         en: """Timeout for the reply to a synchronous RPC."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_socket_keepalive_idle {
                   desc {
                         en: """How long the connections between the brokers should remain open after the last message is sent."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_socket_keepalive_interval {
                   desc {
                         en: """The interval between keepalive messages."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_socket_keepalive_count {
                   desc {
                         en: """How many times the keepalive probe message can fail to receive a reply until the RPC connection is considered lost."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_socket_sndbuf {
                   desc {
                         en: """TCP tuning parameters. TCP sending buffer size."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_socket_recbuf {
                   desc {
                         en: """TCP tuning parameters. TCP receiving buffer size."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    rpc_socket_buffer {
                   desc {
                         en: """TCP tuning parameters. Socket buffer size in user mode."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    log_file_handlers {
                   desc {
                         en: """Key-value list of file-based log handlers."""
                         zh: """基于文件的日志处理进程的键值列表。"""
                        }
                   label: {
                           en: "Log Handlers Key Val List"
                           zh: "日志处理进程键值列表"
                          }
                  }

    log_error_logger {
                   desc {
                         en: """Deprecated."""
                         zh: """该配置已弃用。"""
                        }
                   label: {
                           en: "Deprecate"
                           zh: "配置已弃用"
                          }
                  }

    console_handler_enable {
                   desc {
                         en: """Enable this log handler."""
                         zh: """启用此日志处理进程。"""
                        }
                   label: {
                           en: "Enable Log Handler"
                           zh: "启用日志处理进程"
                          }
                  }

    console_handler_level {
                   desc {
                         en: """Global log level. This includes the primary log level and all log handlers."""
                         zh: """全局日志级别。 这包括主日志级别和所有日志处理进程。"""
                        }
                   label: {
                           en: "Global Log Level"
                           zh: "全局日志级别"
                          }
                  }

    console_handler_time_offset {
                   desc {
                         en: """The time offset to be used when formatting the timestamp."""
                         zh: """格式化时间戳时，使用的时间偏移量。"""
                        }
                   label: {
                           en: "Time Offset"
                           zh: "时间偏移量"
                          }
                  }

    console_handler_chars_limit {
                   desc {
                         en: """Set the maximum length of a single log message. If this length is exceeded, the log message will be truncated."""
                         zh: """设置单个日志消息的最大长度。 如果超过此长度，则日志消息将被截断。"""
                        }
                   label: {
                           en: "Single Log Max Length"
                           zh: "单个日志最大长度"
                          }
                  }

    console_handler_formatter {
                   desc {
                         en: """Choose log format. <code>text</code> for free text, and <code>json</code> for structured logging."""
                         zh: """选择日志格式。 <code>text</code> 用于自由文本，<code>json</code> 用于结构化日志记录。"""
                        }
                   label: {
                           en: "Log Format"
                           zh: "日志格式"
                          }
                  }

    console_handler_single_line {
                   desc {
                         en: """Print logs in a single line if set to true. Otherwise, log messages may span multiple lines."""
                         zh: """如果设置为 true，则在一行中打印日志。 否则，日志消息可能跨越多行。"""
                        }
                   label: {
                           en: "Single Line Mode"
                           zh: "单行模式"
                          }
                  }

    console_handler_sync_mode_qlen {
                   desc {
                         en: """As long as the number of buffered log events is lower than this value, all log events are handled asynchronously."""
                         zh: """只要缓冲的日志事件的数量低于这个值，所有的日志事件都会被异步处理。"""
                        }
                   label: {
                           en: "Sync Mode Max Log Events"
                           zh: "异步模式最大事件数"
                          }
                  }

    console_handler_drop_mode_qlen {
                   desc {
                         en: """When the number of buffered log events is larger than this value, the new log events are dropped.<br/>When drop mode is activated or deactivated, a message is printed in the logs."""
                         zh: """当缓冲的日志事件数大于此值时，新的日志事件将被丢弃。<br/>启用或停用丢弃模式时，会在日志中打印一条消息。"""
                        }
                   label: {
                           en: "Drop Mode Max Log Events"
                           zh: "缓存最大日志事件数"
                          }
                  }

    console_handler_flush_qlen {
                   desc {
                         en: """If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place. To flush events, the handler discards the buffered log messages without logging."""
                         zh: """如果缓冲日志事件的数量增长大于此阈值，则会发生刷新（删除）操作。 为了完成刷新事件，处理进程丢弃缓冲的日志消息。"""
                        }
                   label: {
                           en: "Flush Threshold"
                           zh: "刷新阈值"
                          }
                  }

    console_handler_supervisor_reports {
                   desc {
                         en: """Type of supervisor reports that are logged.
 - `error`: only log errors in the Erlang processes.
 - `progress`: log process startup."""
                         zh: """ supervisor 报告的类型。
  - `error`：仅记录 Erlang 进程中的错误。
  - `progress`：记录进程启动。"""
                        }
                   label: {
                           en: "Report Type"
                           zh: "报告类型"
                          }
                  }

    console_handler_max_depth {
                   desc {
                         en: """Maximum depth for Erlang term log formatting and Erlang process message queue inspection."""
                         zh: """Erlang 内部格式日志格式化和 Erlang 进程消息队列检查的最大深度。"""
                        }
                   label: {
                           en: "Max Depth"
                           zh: "最大深度"
                          }
                  }

    log_file_handler_file {
                   desc {
                         en: """Name the log file."""
                         zh: """日志文件名字。"""
                        }
                   label: {
                           en: "Log File Name"
                           zh: "日志文件名字"
                          }
                  }

    log_file_handler_max_size {
                   desc {
                         en: """This parameter controls log file rotation. The value `infinity` means the log file will grow indefinitely, otherwise the log file will be rotated once it reaches `max_size` in bytes."""
                         zh: """此参数控制日志文件轮换。 `infinity` 意味着日志文件将无限增长，否则日志文件将在达到 `max_size`（以字节为单位）时进行轮换。"""
                        }
                   label: {
                           en: "Rotation Size"
                           zh: "日志文件轮换大小"
                          }
                  }

    log_file_handler_enable {
                   desc {
                         en: """Enable this log handler."""
                         zh: """启用此日志处理进程。"""
                        }
                   label: {
                           en: "Enable Log Handler"
                           zh: "启用此日志处理进程"
                          }
                  }

    log_file_handler_level {
                   desc {
                         en: """Global log level. This includes the primary log level and all log handlers."""
                         zh: """全局日志级别。 这包括主日志级别和所有日志处理进程。"""
                        }
                   label: {
                           en: "Global Level"
                           zh: "全局日志级别"
                          }
                  }

    log_file_handler_time_offset {
                   desc {
                         en: """The time offset to be used when formatting the timestamp."""
                         zh: """格式化时间戳时要使用的时间偏移量。"""
                        }
                   label: {
                           en: "Time Offset"
                           zh: "时间偏移"
                          }
                  }

    log_file_handler_chars_limit {
                   desc {
                         en: """Set the maximum length of a single log message. If this length is exceeded, the log message will be truncated."""
                         zh: """设置单个日志消息的最大长度。 如果超过此长度，则日志消息将被截断。"""
                        }
                   label: {
                           en: "Single Log Max Length"
                           zh: "单个日志消息最大长度"
                          }
                  }

    log_file_handler_formatter {
                   desc {
                         en: """Choose log format. <code>text</code> for free text, and <code>json</code> for structured logging."""
                         zh: """选择日志格式。 <code>text</code> 用于自由文本，<code>json</code> 用于结构化日志记录。"""
                        }
                   label: {
                           en: "Log Format"
                           zh: "日志格式"
                          }
                  }

    log_file_handler_single_line {
                   desc {
                         en: """Print logs in a single line if set to true. Otherwise, log messages may span multiple lines."""
                         zh: """如果设置为 true，则在一行中打印日志。 否则，日志消息可能跨越多行。"""
                        }
                   label: {
                           en: "Single Line Mode"
                           zh: "单行模式"
                          }
                  }

    log_file_handler_sync_mode_qlen {
                   desc {
                         en: """As long as the number of buffered log events is lower than this value, all log events are handled asynchronously."""
                         zh: """只要缓冲的日志事件的数量低于这个值，所有的日志事件都会被异步处理。"""
                        }
                   label: {
                           en: "Sync Mode Max Log Events"
                           zh: "异步模式最大事件数"
                          }
                  }

    log_file_handler_drop_mode_qlen {
                   desc {
                         en: """When the number of buffered log events is larger than this value, the new log events are dropped.<br/>When drop mode is activated or deactivated, a message is printed in the logs."""
                         zh: """当缓冲的日志事件数大于此值时，新的日志事件将被丢弃。<br/>启用或停用丢弃模式时，会在日志中打印一条消息。"""
                        }
                   label: {
                           en: "Drop Mode Max Log Events"
                           zh: "缓存最大日志事件数"
                          }
                  }

    log_file_handler_flush_qlen {
                   desc {
                         en: """If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place. To flush events, the handler discards the buffered log messages without logging."""
                         zh: """如果缓冲日志事件的数量增长大于此阈值，则会发生刷新（删除）操作。 为了完成刷新事件，处理进程丢弃缓冲的日志消息。"""
                        }
                   label: {
                           en: "Flush Threshold"
                           zh: "刷新阈值"
                          }
                  }

    log_file_handler_supervisor_reports {
                   desc {
                         en: """Type of supervisor reports that are logged.
 - `error`: only log errors in the Erlang processes.
 - `progress`: log process startup."""
                         zh: """ supervisor 报告的类型。
  - `error`：仅记录 Erlang 进程中的错误。
  - `progress`：记录进程启动。"""
                        }
                   label: {
                           en: "Report Type"
                           zh: "报告类型"
                          }
                  }

    log_file_handler_max_depth {
                   desc {
                         en: """Maximum depth for Erlang term log formatting and Erlang process message queue inspection."""
                         zh: """Erlang 内部格式日志格式化和 Erlang 进程消息队列检查的最大深度。"""
                        }
                   label: {
                           en: "Max Depth"
                           zh: "最大深度"
                          }
                  }

    log_rotation_enable {
                   desc {
                         en: """Enable log rotation feature."""
                         zh: """启用日志轮换功能。"""
                        }
                   label: {
                           en: "Rotation Enable"
                           zh: "日志轮换"
                          }
                  }

    log_rotation_count {
                   desc {
                         en: """Maximum number of log files."""
                         zh: """最大日志文件数。"""
                        }
                   label: {
                           en: "Max Log Files Number"
                           zh: "最大日志文件数"
                          }
                  }

    log_overload_kill_enable {
                   desc {
                         en: """Enable log handler overload kill feature."""
                         zh: """启用日志处理进程过载终止功能。"""
                        }
                   label: {
                           en: "Log Handler Overload Kill"
                           zh: "日志处理进程过载终止"
                          }
                  }

    log_overload_kill_mem_size {
                   desc {
                         en: """Maximum memory size that the handler process is allowed to use."""
                         zh: """处理进程进程允许使用的最大内存。"""
                        }
                   label: {
                           en: "Handler Allowed Max Memory Size"
                           zh: "理进程进程允许使用的最大内存"
                          }
                  }

    log_overload_kill_qlen {
                   desc {
                         en: """Maximum allowed queue length."""
                         zh: """允许的最大队列长度。"""
                        }
                   label: {
                           en: "Max Queue Length"
                           zh: "最大队列长度"
                          }
                  }

    log_overload_kill_restart_after {
                   desc {
                         en: """If the handler is terminated, it restarts automatically after a delay specified in milliseconds. The value `infinity` prevents restarts."""
                         zh: """如果处理进程终止，它会在以毫秒为单位指定的延迟后自动重新启动。 `infinity` 防止重新启动。"""
                        }
                   label: {
                           en: "Handler Restart Delay"
                           zh: "处理进程重启延迟"
                          }
                  }

    log_burst_limit_enable {
                   desc {
                         en: """Enable log burst control feature."""
                         zh: """启用日志突发控制功能。"""
                        }
                   label: {
                           en: "Enable Burst"
                           zh: "启用日志突发控制"
                          }
                  }

    log_burst_limit_max_count {
                   desc {
                         en: """Maximum number of log events to handle within a `window_time` interval. After the limit is reached, successive events are dropped until the end of the `window_time`."""
                         zh: """在 `window_time` 间隔内处理的最大日志事件数。 达到限制后，将丢弃连续事件，直到 `window_time` 结束。"""
                        }
                   label: {
                           en: "Events Number"
                           zh: "日志事件数"
                          }
                  }

    log_burst_limit_window_time {
                   desc {
                         en: """See `max_count`."""
                         zh: """参考 `max_count`。"""
                        }
                   label: {
                           en: "Window Time"
                           zh: "Window Time"
                          }
                  }

    authorization {
                   desc {
                         en: """
Authorization a.k.a. ACL.<br>
In EMQX, MQTT client access control is extremely flexible.<br>
An out-of-the-box set of authorization data sources are supported.
For example,<br>
'file' source is to support concise and yet generic ACL rules in a file;<br>
'built_in_database' source can be used to store per-client customizable rule sets,
natively in the EMQX node;<br>
'http' source to make EMQX call an external HTTP API to make the decision;<br>
'PostgreSQL' etc. to look up clients or rules from external databases;<br>
"""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    desc_cluster {
                   desc {
                         en: """EMQX nodes can form a cluster to scale up the total capacity.<br>Here holds the configs to instruct how individual nodes can discover each other."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    desc_cluster_static {
                   desc {
                         en: """Service discovery via static nodes. The new node joins the cluster by connecting to one of the bootstrap nodes."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    desc_cluster_mcast {
                   desc {
                         en: """Service discovery via UDP multicast."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    desc_cluster_dns {
                   desc {
                         en: """Service discovery via DNS SRV records."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    desc_cluster_etcd {
                   desc {
                         en: """Service discovery using 'etcd' service."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    desc_cluster_k8s {
                   desc {
                         en: """Service discovery via Kubernetes API server."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    desc_node {
                   desc {
                         en: """Node name, cookie, config & data directories and the Erlang virtual machine (BEAM) boot parameters."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    desc_db {
                   desc {
                         en: """Settings for the embedded database."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    desc_cluster_call {
                   desc {
                         en: """Options for the 'cluster call' feature that allows to execute a callback on all nodes in the cluster."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    desc_rpc {
                   desc {
                         en: """EMQX uses a library called <code>gen_rpc</code> for inter-broker communication.<br/>Most of the time the default config should work, but in case you need to do performance fine-tuning or experiment a bit, this is where to look."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

    desc_log {
                   desc {
                         en: """EMQX logging supports multiple sinks for the log events. Each sink is represented by a _log handler_, which can be configured independently."""
                         zh: """EMQX 日志记录支持日志事件的多个接收器。 每个接收器由一个_log handler_表示，可以独立配置。"""
                        }
                   label: {
                           en: "Log"
                           zh: "日志"
                          }
                  }

    desc_console_handler {
                   desc {
                         en: """Log handler that prints log events to the EMQX console."""
                         zh: """日志处理进程将日志事件打印到 EMQX 控制台。"""
                        }
                   label: {
                           en: "Console Log Handler"
                           zh: "控制台日志处理进程"
                          }
                  }

    desc_log_file_handler {
                   desc {
                         en: """Log handler that prints log events to files."""
                         zh: """日志处理进程将日志事件打印到文件。"""
                        }
                   label: {
                           en: "Files Log Handler"
                           zh: "文件日志处理进程"
                          }
                  }

    desc_log_rotation {
                   desc {
                         en: """By default, the logs are stored in `./log` directory (for installation from zip file) or in `/var/log/emqx` (for binary installation).<br/>This section of the configuration controls the number of files kept for each log handler."""
                         zh: """默认情况下，日志存储在 `./log` 目录（用于从 zip 文件安装）或 `/var/log/emqx`（用于二进制安装）。<br/>这部分配置，控制每个日志处理进程保留的文件数量。"""
                        }
                   label: {
                           en: "Log Rotation"
                           zh: "日志轮换"
                          }
                  }

    desc_log_overload_kill {
                   desc {
                         en: """Log overload kill features an overload protection that activates when the log handlers use too much memory or have too many buffered log messages.<br/>When the overload is detected, the log handler is terminated and restarted after a cooldown period."""
                         zh: """日志过载终止，具有过载保护功能。当日志处理进程使用过多内存，或者缓存的日志消息过多时该功能被激活。<br/>检测到过载时，日志处理进程将终止，并在冷却期后重新启动。"""
                        }
                   label: {
                           en: "Log Overload Kill"
                           zh: "日志过载保护"
                          }
                  }

    desc_log_burst_limit {
                   desc {
                         en: """Large bursts of log events produced in a short time can potentially cause problems, such as:
 - Log files grow very large
 - Log files are rotated too quickly, and useful information gets overwritten
 - Overall performance impact on the system

Log burst limit feature can temporarily disable logging to avoid these issues."""
                         zh: """短时间内产生的大量日志事件可能会导致问题，例如：
  - 日志文件变得非常大
  - 日志文件轮换过快，有用信息被覆盖
  - 对系统的整体性能影响

日志突发限制功能可以暂时禁用日志记录以避免这些问题。"""
                        }
                   label: {
                           en: "Log Burst Limit"
                           zh: "日志突发限制"
                          }
                  }

    desc_authorization {
                   desc {
                         en: """Settings that control client authorization."""
                         zh: """"""
                        }
                   label: {
                           en: ""
                           zh: ""
                          }
                  }

}
