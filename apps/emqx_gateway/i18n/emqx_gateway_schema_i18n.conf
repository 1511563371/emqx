emqx_gateway_schema {

    stomp {
        desc {
            en: """The Stomp Gateway configuration.
This gateway supports v1.2/1.1/1.0"""
            zh: """Stomp 网关配置。当前实现支持 v1.2/1.1/1.0 协议版本"""
        }
    }

    stom_frame_max_headers {
        desc {
            en: """The maximum number of Header"""
            zh: """ """
        }
    }

    stomp_frame_max_headers_length {
        desc {
            en: """The maximum string length of the Header Value"""
            zh: """ """
        }
    }

    stom_frame_max_body_length {
        desc {
            en: """Maximum number of bytes of Body allowed per Stomp packet"""
            zh: """ """
        }
    }

    mqttsn {
        desc {
            en: """The MQTT-SN Gateway configuration.
This gateway only supports the v1.2 protocol"""
            zh: """MQTT-SN 网关配置。当前实现仅支持 v1.2 版本"""
        }
    }

    mqttsn_gateway_id {
        desc {
            en: """MQTT-SN Gateway ID.
When the <code>broadcast</code> option is enabled, the gateway will broadcast ADVERTISE message with this value"""
            zh: """ """
        }
    }

    mqttsn_broadcast {
        desc {
            en: """Whether to periodically broadcast ADVERTISE messages"""
            zh: """ """
        }
    }

    mqttsn_enable_qos3 {
        desc {
            en: """Allows connectionless clients to publish messages with a Qos of -1.
This feature is defined for very simple client implementations which do not support any other features except this one. There is no connection setup nor tear down, no registration nor subscription. The client just sends its 'PUBLISH' messages to a GW"""
            zh: """ """
        }
    }

    mqttsn_subs_resume {
        desc {
            en: """Whether to initiate all subscribed topic name registration messages to the client after the Session has been taken over by a new channel"""
            zh: """ """
        }
    }

    mqttsn_predefined {
        desc {
            en: """The pre-defined topic IDs and topic names.
A 'pre-defined' topic ID is a topic ID whose mapping to a topic name is known in advance by both the client's application and the gateway"""
            zh: """ """
        }
    }

    mqttsn_predefined_id {
        desc {
            en: """Topic ID.<br>Range: 1-65535"""
            zh: """ """
        }
    }

    mqttsn_predefined_topic {
        desc {
            en: """Topic Name"""
            zh: """ """
        }
    }

    coap {
        desc {
            en: """The CoAP Gateway configuration.<br>\n
This gateway is implemented based on RFC-7252 and https://core-wg.github.io/coap-pubsub/draft-ietf-core-pubsub.html"""
            zh: """ """
        }
    }

    coap_heartbeat {
        desc {
            en: """The gateway server required minimum heartbeat interval.
When connection mode is enabled, this parameter is used to set the minimum heartbeat interval for the connection to be alive"""
            zh: """ """
        }
    }

    coap_connection_required {
        desc {
            en: """Enable or disable connection mode.
Connection mode is a feature of non-standard protocols. When connection mode is enabled, it is necessary to maintain the creation, authentication and alive of connection resources"""
            zh: """ """
        }
    }

    coap_notify_type {
        desc {
            en: """The Notification Message will be delivered to the CoAP client if a new message received on an observed topic.
The type of delivered coap message can be set to:
  1. non: Non-confirmable;
  2. con: Confirmable;
  3. qos: Mapping from QoS type of received message, QoS0 -> non, QoS1,2 -> con"""
            zh: """ """
        }
    }

    coap_subscribe_qos {
        desc {
            en: """The Default QoS Level indicator for subscribe request.
This option specifies the QoS level for the CoAP Client when establishing a subscription membership, if the subscribe request is not carried `qos` option. The indicator can be set to:
  - qos0, qos1, qos2: Fixed default QoS level
  - coap: Dynamic QoS level by the message type of subscribe request
    * qos0: If the subscribe request is non-confirmable
    * qos1: If the subscribe request is confirmable"""

            zh: """ """
        }
    }

    coap_publish_qos {
        desc {
            en: """The Default QoS Level indicator for publish request.
This option specifies the QoS level for the CoAP Client when publishing a message to EMQX PUB/SUB system, if the publish request is not carried `qos` option. The indicator can be set to:
  - qos0, qos1, qos2: Fixed default QoS level
  - coap: Dynamic QoS level by the message type of publish request
    * qos0: If the publish request is non-confirmable
    * qos1: If the publish request is confirmable"""

            zh: """ """
        }
    }

    lwm2m {
        desc {
            en: """The LwM2M Gateway configuration.
This gateway only supports the v1.0.1 protocol"""
            zh: """ """
        }
    }

    lwm2m_xml_dir {
        desc {
            en: """The Directory for LwM2M Resource definition"""
            zh: """ """
        }
    }

    lwm2m_lifetime_min {
        desc {
            en: """Minimum value of lifetime allowed to be set by the LwM2M client"""
            zh: """ """
        }
    }

    lwm2m_lifetime_max {
        desc {
            en: """Maximum value of lifetime allowed to be set by the LwM2M client"""
            zh: """ """
        }
    }

    lwm2m_qmode_time_window {
        desc {
            en: """The value of the time window during which the network link is considered valid by the LwM2M Gateway in QMode mode.
For example, after receiving an update message from a client, any messages within this time window are sent directly to the LwM2M client, and all messages beyond this time window are temporarily stored in memory."""

            zh: """ """
        }
    }

    lwm2m_auto_observe {
        desc {
            en: """Automatically observe the object list of REGISTER packet"""
            zh: """ """
        }
    }

    lwm2m_update_msg_publish_condition {
        desc {
            en: """"Policy for publishing UPDATE event message.
  - always: send update events as long as the UPDATE request is received.
  - contains_object_list: send update events only if the UPDATE request carries any Object List"""

            zh: """ """
        }
    }

    lwm2m_translators {
        desc {
            en: """Topic configuration for LwM2M's gateway publishing and subscription"""
            zh: """ """
        }
    }

    lwm2m_translators_command {
        desc {
            en: """The topic for receiving downstream commands.
For each new LwM2M client that succeeds in going online, the gateway creates a subscription relationship to receive downstream commands and send it to the LwM2M client"""

            zh: """ """
        }
    }

    lwm2m_translators_response {
        desc {
            en: """The topic for gateway to publish the acknowledge events from LwM2M client"""
            zh: """ """
        }
    }

    lwm2m_translators_notify {
        desc {
            en: """The topic for gateway to publish the notify events from LwM2M client.
After succeed observe a resource of LwM2M client, Gateway will send the notify events via this topic, if the client reports any resource changes"""

            zh: """ """
        }
    }

    lwm2m_translators_register {
        desc {
            en: """The topic for gateway to publish the register events from LwM2M client."""
            zh: """ """
        }
    }

    lwm2m_translators_update {
        desc {
            en: """The topic for gateway to publish the update events from LwM2M client"""
            zh: """ """
        }
    }

    translator {
        desc {
            en: """MQTT topic that corresponds to a particular type of event."""
            zh: """ """
        }
    }

    translator_topic {
        desc {
            en: """Which topic the device's upstream message is published to."""
            zh: """ """
        }
    }

    translator_qos {
        desc {
            en: """QoS of the published messages."""
            zh: """ """
        }
    }

    exproto {
        desc {
            en: """The Extension Protocol configuration"""
            zh: """ """
        }
    }

    exproto_server {
        desc {
            en: """Configurations for starting the <code>ConnectionAdapter</code> service"""
            zh: """ """
        }
    }

    exproto_grpc_server_bind {
        desc {
            en: """Listening address and port for the gRPC server."""
            zh: """ """
        }
    }

    exproto_grpc_server_ssl {
        desc {
            en: """SSL configuration for the gRPC server."""
            zh: """ """
        }
    }

    exproto_handler {
        desc {
            en: """Configurations for request to <code>ConnectionHandler</code> service"""
            zh: """ """
        }
    }

    exproto_grpc_handler_address {
        desc {
            en: """gRPC server address."""
            zh: """ """
        }
    }

    exproto_grpc_handler_ssl {
        desc {
            en: """SSL configuration for the gRPC client."""
            zh: """ """
        }
    }

    gateway_common_enable {
        desc {
            en: """Whether to enable this gateway"""
            zh: """ """
        }
    }

    gateway_common_enable_stats {
        desc {
            en: """Whether to enable client process statistic"""
            zh: """ """
        }
    }

    gateway_common_idle_timeout {
        desc {
            en: """The idle time of the client connection process. It has two purposes:
  1. A newly created client process that does not receive any client requests after that time will be closed directly.
  2. A running client process that does not receive any client requests after this time will go into hibernation to save resources."""
            zh: """ """
        }
    }

    gateway_common_mountpoint {
        desc {
            en: """ """
            zh: """ """
        }
    }

    gateway_common_clientinfo_override {
        desc {
            en: """ClientInfo override."""
            zh: """ """
        }
    }

    gateway_common_clientinfo_override_username {
        desc {
            en: """Template for overriding username."""
            zh: """ """
        }
    }
    gateway_common_clientinfo_override_password {
        desc {
            en: """Template for overriding password."""
            zh: """ """
        }
    }
    gateway_common_clientinfo_override_clientid {
        desc {
            en: """Template for overriding clientid."""
            zh: """ """
        }
    }

    gateway_common_authentication {
        desc {
            en: """Default authentication configs for all the gateway listeners. For per-listener overrides see <code>authentication</code>\n in listener configs"""
            zh: """ """
        }
    }

    tcp_udp_listeners {
        desc {
            en: """Settings for the listeners."""
            zh: """ """
        }
    }

    tcp_listeners {
        desc {
            en: """Settings for the TCP listeners."""
            zh: """ """
        }
    }

    udp_listeners {
        desc {
            en: """Settings for the UDP listeners."""
            zh: """ """
        }
    }

    tcp_listener {
        desc {
            en: """ """
            zh: """ """
        }
    }

    tcp_listener_acceptors {
        desc {
            en: """Size of the acceptor pool."""
            zh: """ """
        }
    }

    tcp_listener_tcp_opts{
        desc {
            en: """Setting the TCP socket options."""
            zh: """ """
        }
    }

    tcp_listener_proxy_protocol {
        desc {
            en: """Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.
See: https://www.haproxy.com/blog/haproxy/proxy-protocol/"""
            zh: """ """
        }
    }

    tcp_listener_proxy_protocol_timeout {
        desc {
            en: """Timeout for proxy protocol.
EMQX will close the TCP connection if proxy protocol packet is not received within the timeout."""
            zh: """ """
        }
    }

    ssl_listener {
        desc {
            en: """ """
            zh: """ """
        }
    }

    ssl_listener_options {
        desc {
            en: """SSL listener options."""
            zh: """ """
        }
    }

    udp_listener {
        desc {
            en: """ """
            zh: """ """
        }
    }

    udp_listener_udp_opts {
        desc {
            en: """Settings for the UDP sockets."""
            zh: """ """
        }
    }

    udp_listener_active_n {
        desc {
            en: """Specify the {active, N} option for the socket.
See: https://erlang.org/doc/man/inet.html#setopts-2"""
            zh: """ """
        }
    }

    udp_listener_recbuf {
        desc {
            en: """Size of the kernel-space receive buffer for the socket."""
            zh: """ """
        }
    }

    udp_listener_sndbuf {
        desc {
            en: """Size of the kernel-space send buffer for the socket."""
            zh: """ """
        }
    }

    udp_listener_buffer {
        desc {
            en: """Size of the user-space buffer for the socket."""
            zh: """ """
        }
    }

    udp_listener_reuseaddr {
        desc {
            en: """Allow local reuse of port numbers."""
            zh: """ """
        }
    }

    dtls_listener {
        desc {
            en: """ """
            zh: """ """
        }
    }

    dtls_listener_acceptors {
        desc {
            en: """Size of the acceptor pool."""
            zh: """ """
        }
    }

    dtls_listener_dtls_opts {
        desc {
            en: """DTLS listener options"""
            zh: """ """
        }

    }

    gateway_common_listener_enable {
        desc {
            en: """Enable the listener."""
            zh: """ """
        }
    }

    gateway_common_listener_bind {
        desc {
            en: """The IP address and port that the listener will bind."""
            zh: """ """
        }
    }

    gateway_common_listener_max_connections {
        desc {
            en: """Maximum number of concurrent connections."""
            zh: """ """
        }
    }

    gateway_common_listener_max_conn_rate {
        desc {
            en: """Maximum connections per second."""
            zh: """ """
        }
    }

    gateway_common_listener_mountpoint {
        desc {
            en: """When publishing or subscribing, prefix all topics with a mountpoint string.
The prefixed string will be removed from the topic name when the message is delivered to the subscriber. The mountpoint is a way that users can use to implement isolation of message routing between different listeners.
For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint` set to `some_tenant`, then the client actually subscribes to the topic `some_tenant/t`. Similarly, if another client B (connected to the same listener as the client A) sends a message to topic `t`, the message is routed to all the clients subscribed `some_tenant/t`, so client A will receive the message, with topic name `t`. Set to `\"\"` to disable the feature.
Variables in mountpoint string:
  - <code>${clientid}</code>: clientid
  - <code>${username}</code>: username
"""
            zh: """ """
        }
    }

    gateway_common_listener_access_rules {
        desc {
            en: """The access control rules for this listener.
See: https://github.com/emqtt/esockd#allowdeny"""
            zh: """ """
        }
    }

    gateway_common_listener_enable {
        desc {
            en: """ """
            zh: """ """
        }
    }

}
